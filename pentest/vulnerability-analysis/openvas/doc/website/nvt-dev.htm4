m4_dnl -*-html-*-
m4_include(`template.m4')

m4_dnl OpenVAS
m4_dnl $Id$
m4_dnl Description: This page summarizes all that NVT developers should know.
m4_dnl
m4_dnl Authors:
m4_dnl Jan-Oliver Wagner <jan-oliver.wagner@greenbone.net>
m4_dnl
m4_dnl Copyright:
m4_dnl Copyright (C) 2012-2015 Greenbone Networks GmbH
m4_dnl
m4_dnl This program is free software; you can redistribute it and/or
m4_dnl modify it under the terms of the GNU General Public License
m4_dnl as published by the Free Software Foundation; either version 2
m4_dnl of the License, or (at your option) any later version.
m4_dnl
m4_dnl This program is distributed in the hope that it will be useful,
m4_dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
m4_dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
m4_dnl GNU General Public License for more details.
m4_dnl
m4_dnl You should have received a copy of the GNU General Public License
m4_dnl along with this program; if not, write to the Free Software
m4_dnl Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.

m4_define(`EN')

m4_define(`TITLE', `NVT Development')
m4_define(`MAIN', `development')

PAGE_START

<h2>NVT Development</h2>

<p>
This page collects hints and guides for developing
Network Vulnerability Tests.
</p>

<ul>
<li> <a href="#how_to_start">How to start</a> </li>
<li> <a href="#golden_rules">Golden Rules</a> </li>
<li> <a href="#product_detection_nvt">How to write a product detection NVT</a> </li>
<li> <a href="#policy_nvt">How to write a policy NVT</a> </li>
<li> <a href="#miscellaneous">Miscellaneous</a> </li>
<li> <a href="#how_to_assign_cvss">How to assign a CVSS to a NVT</a> </li>
<ul>
  <li> <a href="#scoring_guidelines">Scoring Guidelines</a> </li>
  <li> <a href="#how_to_score">How to score</a> </li>
  <li> <a href="#references">References</a> </li>
</ul>
<li> <a href="#how_to_deprecate_nvt">How to deprecate a NVT</a> </li>
<li> <a href="#how_to_handle_rejected_cve">How to handle references to CVEs that are marked REJECTED</a></li>
<li> <a href="#how_to_handle_no_solution">How to handle NVTs with "no solution" for the user</a></li>
<li> <a href="#how_to_assign_qod">How to assign a QoD to a NVT</a></li>
<li> <a href="#how_to_assign_solution_type">How to assign a solution type to a NVT</a></li>
</ul>

<a name="how_to_start"></a>
<h3>How to start</h3>

<p>
The NVT development is not well documented.<br/ >
But you will find other developers for questions and discussions
on the <a href="mail.html">NVT Development Mailing List</a>
</p>

<p>
The best start is to learn from existing NASL scripts.<br/ >
There is also a template you can begin with:
<a href="https://wald.intevation.org/scm/viewvco.php/template.nasl?root=openvas-nvts&view=log">template.nasl</a>
</p>

<p>
License requirements: We welcome any contribution licensed under GNU GPLv2+.<br/>
These can easily go into the OpenVAS Feed to benefit everyone.<br/>
Other licenses might create legal conflicts and in doubt you should simply
ask the other NVT developers.
</p>

<a name="golden_rules"></a>
<h3>Golden Rules</h3>

<p>
This is a collection assembled over time from lessons learned.
</p>

<ul>

<li> <p>
     Avoid writing your own product detection inside a vulnerability check.
     </p>
     <p>
     Rationale: We separate product detection from actual vulnerability check where ever possible.
     You will find various detection scripts in the OpenVAS repository and should check whether there
     is already one you can use.
     Usually these scripts have a "detect* in their filename and you can search for other NVTs on how to use it.
     </p>

     <p>
     In case there is no detection yet, consider writing a new detection script so it can be
     re-used in the future. In doubt how to do that or whether it makes sense in some special cases,
     just get in contact with the developers at openvas-plugins mailing list.
     </p>

<li> <p>
     Use product detection result in proper way (example: gb_openssl_dos_vuln_lin_jun09.nasl).
     </p>

     <p>
     You can do so by doing the following:
     </p>

     <ul>

    <li> You will need these includes:
<pre>
include("version_func.inc");
include("host_details.inc");
</pre>
     </li>

     <li> Add the dependency to the detection:
<pre>
script_dependencies("gb_openssl_detect_lin.nasl");
</pre>
     </li>

     <li> Add a key requirement to ensure the scripts doesn't run in unnecessary situations like:
<pre>
script_require_keys("PostgreSQL/installed");
</pre>
     </li>

     <li> Use get_app_version() to work with the version number:
<pre>
ver = get_app_version(cpe:"cpe:/a:openssl:openssl");
</pre>
     </li>
     </ul>

     <p>
     Rationale: This enables product detection references inside vulnerability report as featured since OpenVAS-5.
     </p>

<li> <p>
     Don't add any port scanner as dependency.
     </p>
     <p>
     Rationale: Since the user should decide on her own which scanner to use,
     this could lead to situations where more then one port scanner is concurrently executed.
     </p>

<li> <p>
     Don't use "toolchecks.nasl" as dependency if your NVT does not directly(!) use one of
     the tools listed in toolcheck.nasl.
     </p>
     <p>
     Rationale: It's simply useless. Though it has no effect it creates a wrong
     impression when reading the code.
     </p>

</li>

<li> <p>
     If you use "script_mandatory_keys("login/SSH/success");" then you also
     need to apply "script_dependencies("ssh_authorization.nasl");".
     </p>
     <p>
     Rationale: The key will only be set when ssh_authorization is executed.
     </p>

</li>

<li> <p>
     Use "script_mandatory_keys()" (also instead of "script_require_keys()") if
     the script does not do anything sensible if a key is not available.
     </p>

     <p>
     For example: Use "script_mandatory_keys("MyApp/Linux/Version");" if your script
     starts like this with a very early exit():
     </p>

<pre>
include("version_func.inc");

myappVer = get_kb_item("MyApp/Linux/Version");
if(!myappVer){
  exit(0);
}
...
</pre>

     <p>
     Rationale: Using script_mandatory_keys will prevent that the NVT is executed at all; even
     if optimize_tests setting is disabled. This improves the scan performance.
     </p>
</li>


<li> <p>
     Don't use UTF-8 encoding for your NVT. For the time being (as long as old scanner protocol OTP
     is supported), the encoding to be used for NVTs is  ISO-8859-1.
     </p>
     <p>
     Rationale: Is is actually not a big issue for openvas-scanner since it mostly just passes
     along the string, but can create trouble in modules processing the
     output of openvas-scanner, like openvas-manager or openvas-client. Since
     OTP 1.0 does not specify an encoding, they generally assume that everything
     they get from openvas-scanner is ISO-8859 encoded and will try to
     convert it.<br/>
     This means that the encoding will be messed up if the NVT was already
     UTF-8 encoded which can result in anything from funny looking characters
     to incomplete reports.
     </p>
</li>

<li> <p>
     Place a newly developed NVT into the subdirectory named as the current year (e.g. 2013/).
     Important exceptions are:
     </p>
     <ul>
     <li>
     NVTs that are used as dependencies for others. This covers for example all detection NVTs.
     </li>
     <li>
     Any include files.
     </li>
     </ul>
</li>

</ul>

<a name="product_detection_nvt"></a>
<h3>How to write a product detection NVT</h3>

<p>
It is very important for the NVT Feed that we separate the work
of the detection a certain product from actual vulnerability
evaluation.
The actual detection NVTs should result a CPE code for the product.
If none is available yet, it needs to be registered with NIST.
Also it is very important to explain the method how the product was detected
(description) and where it was detected (result).
</p>

<p>
A good example for a authenticated product detection is gb_openssl_dectect_lin.nasl.
Watch out for these elements:
</p>

<ul>
<li> <p> script_tag(name:"detection", value:"..."): Always set the type of detection. This could
     be "executable version check" or "remote banner" and we can agree on further if needed.
</p> </li>
<li> <p> script_name("..."): Use a simple direct name like ""OpenSSL Version Detection (Linux)".
</p> </li>
<li> <p> script_description("..."): Explain how the product is detected. For example:
<pre>
"Detection of installed version of OpenSSL.

The script logs in via ssh, searches for executable 'openssl' and
queries the found executables via command line option 'version'."
</pre>

</p> </li>

<li> <p> script_family("Product detection"): apply this family.
</p> </li>

<li> <p> Necessary include's: include("cpe.inc"); include("host_details.inc");
</p> </li>

<li> <p> Build a CPE and register the product:

<pre>
cpe = build_cpe(value:sslVer[1], exp:"^([0-9.]+[a-z0-9]*)", base:"cpe:/a:openssl:openssl:");
if(!isnull(cpe))
  register_product(cpe:cpe, location:executableFile);
</pre>
</p> </li>

<li> <p> log_message(): Always send a log message with as detailed and helpful information as
     possible. Here is a good example for the OpenSSL local detection:

<pre>
log_message(data:
  build_detection_report(app:"OpenSSL",
  version: sslVer[1],
  install: executableFile,
  cpe: cpe, 
  concluded:sslVer[max_index(sslVer)-1]),
  port:0);
</pre>

</p> </li>

<li> <p> Finally set a key to help scan scheduler like this example:
<pre>
set_kb_item(name:"PostgreSQL/installed", value:TRUE);
</pre>
</ul>
<p>
</p>

<p>
</p>

<a name="policy_nvt"></a>
<h3>How to write a policy NVT</h3>

<p>
A policy NVT does not search for a documented general vulnerability.
It rather tests a target system for properties that a user defines.
</p>

<p>
In order to allow the user to configure the severity level, a policy
is split into 4 parts. For the following example you will find a
reference implementation with NAME=file_checksums:
</p>

<ul>
<li> Policy/policy_NAME.nasl: The main routine that offers and manages
     the user preferences. Furthermore it will execute the policy checks
     and store the results in the internal knowledge base.
     This NVT will not report anything except "error" in
     case it fails fundamentally.
</li>
<li> Policy/policy_NAME_violation.nasl: Creates a log-result for all
     policy violations.
<li> Policy/policy_NAME_ok.nasl: Creates a log-result for all
     policies that were met.
<li> Policy/policy_NAME_error.nasl: Creates a log-result for all
     policies where an error occurred while trying to check. For example
     if a file could not be accessed due to permission problems.
</ul>

<p>
The routines "_violation", "_ok" and "_error" report log level. The user
can define appropriate Overrides in the Manager and assign severities as
felt appropriate. Those Overrides are typically configured to be applied
generally for all tasks and/or IPs.
</p>

<p>
Developers should implement their policies as close to the reference example
as possible, especially in terms of naming scheme and code structure.
</p>

<a name="miscellaneous"></a>
<h3>Miscellaneous</h3>

<ul>

<li> <p>
     Secret information in the Knowledge Base.
     </p>
     <p>
     If you are handling secret information like passwords in the KB, you
     should prefix the name with "Secret/". Then these values are not written
     to disk into kb-files.
     </p>

</li>

</ul>
<a name="how_to_assign_cvss"></a>
<h3>How to assign a CVSS to a NVT</h3>

<p>
Any new NVT must be provided with a CVSS Score and a CVSS Base Vector.
</p>

<p>
Common Vulnerability Scoring System (CVSS) is an industry standard for assessing the severity
of computer system security vulnerabilities. CVSS is composed of three metric groups:
</p>

<ol>
<li> Base Metrics </li>
<li> Temporal Metric Group </li>
<li> Environmental Metric Group </li>
</ol>

<p>
For NVT development purposes, we only use Base Metrics. Where linked to other
security information (for example CVE), these are automatically updated over time.
The information is captured in the following tags in NVT:
</p>

<pre>
script_tag(name:"cvss_base", value:"x.x");
script_tag(name:"cvss_base_vector", value:"AV:N/AC:M/Au:N/C:P/I:C/A:C");
</pre>

<p>
Follow these steps for assigning a CVSS:
</p>

<ol>
<li>
  <p>
  If there is a CVE for which NVT is being developed, take the CVSS score already computed
  from NVD (National Vulnerability Database), <a href="http://web.nvd.nist.gov/view/vuln/search">http://web.nvd.nist.gov/view/vuln/search</a>.
  </p>

  <p>
  In case multiple CVEs are referenced, pick the one with the Maximum CVSS
  Base and take the corresponding CVSS Base Vector.
  </p>

  <p>
  It is not allowed to apply any other CVSS in case at least one CVE is
  referenced that offers a CVSS. In case author likes to apply another CVSS,
  a second NVT should be added that has no CVE reference and a CVSS of its own.
  However, the better approach is to submit a rationale to NIST if you think the
  CVSS is wrong for the respective vulnerability.
  </p>

</li>

<li>
  <p>
  If there is a CVE for which NVT is being developed and if CVSS is not yet available
  at NVD, manually compute the CVSS score based on the guideline described below.
  </p>
</li>

<li>
  <p>
  If there is non-CVE vulnerability reference for which NVT is being developed, manually
  compute the CVSS score based on the guidelines described below.
  </p>
</li>

</ol>

<a name="scoring_guidelines"></a>
<h4>Scoring Guidelines</h4>

<p>
Base score is a score in the range of 0.0-10.0 at steps of 0.1.
The attributes for computing CVSS Base Score are:
</p>

<ol>
<li>
  <p>Access Vector</p>
  <p>The metric reflects how the vulnerability is exploited. Possible values are:</p>
  <p>
  <ul>
  <li>Local(L): local system, shell account</li>
  <li>Adjacent Network(A): Attack is from an adjacent network</li>
  <li>Network(N): Through network</li>
  </ul>
  </p>
</li>

<li>
  <p>Access Complexity</p>
  <p>Measures the complexity of the attack required to exploit the vulnerability. Possible
     values are:</p>
  <p>
  <ul>
  <li>High(H): If it is too complex to perform an attack. For example, not a default configuration
     race condition</li>
  <li>Medium(M): Some kind of privilege is required, non-default setting</li>
  <li>Low(L): easy to exploit</li>
  </ul>
  </p>
</li>

<li>
  <p>Authentication</p>
  <p>Measures the number of times an attacker must authenticate to a target in order to exploit.
   Possible values are:</p>
  <p>
  <ul>
  <li>Multiple(M): multiple authentication is required</li>
  <li>Single(S): one instance of authentication is required</li>
  <li>None(N): No authentication is required</li>
  </ul>
  </p>
</li>

<li>
  <p>Confidentiality</p>
  <p>Measures the impact on confidentiality of a successfully exploited vulnerability. Possible
   values are:</p>
  <p>
  <ul>
  <li>None(N)</li>
  <li>Partial(P)</li>
  <li>Complete(C)</li>
  </ul>
  </p>
</li>

<li>
  <p>Integrity</p>
  <p>Measures the impact to integrity of a successfully exploited vulnerability. Possible values
   are:</p>
  <p>
  <ul>
  <li>None(N)</li>
  <li>Partial(P)</li>
  <li>Complete(C)</li>
  </ul>
  </p>
</li>

<li>
  <p>Availability</p>
  <p>Measures the impact to availability of a successfully exploited vulnerability. Possible values
   are:</p>
  <p>
  <ul>
  <li>None(N)</li>
  <li>Partial(P)</li>
  <li>Complete(C)</li>
  </ul>
  </p>
</li>

</ol>

<p>
Base Metrics: AV:[L,A,N]/AC:[H,M,L]/Au:[M,S,N]/C:[N,P,C]/I:[N,P,C]/A:[N,P,C]
</p>

<p>
The following tips can be applied while scoring:
</p>

<ul>

<li><p>
  Consider the direct impact a vulnerability will have on the target
</p></li>

<li><p>
  If there are multiple vulnerabilities NVT is addressing, for scoring purposes for each of the
  above attributes, consider the vulnerability which will have high impact on the target (the
  one that yields high score)
</p></li>

<li><p>
  If multiple options can be selected for each attribute, consider the one that will have high
  impact on the target.
</p></li>

<li><p>
  In general, the following Confidentiality, Integrity and Availability values can be applied
  for different type of vulnerability.
  </p>

  <p>Denial of Service:</p>
  <p>
  <ol>
  <li>Confidentiality is None(N)</li>
  <li>Integrity is None(N)</li>
  <li>Availability is either Partial(P) or Complete(C)</li>
  </ol>
  </p>

  <p>Buffer overflow vulnerability:</p>
  <p>
  <ol>
  <li>Confidentiality is Partial(P) or Complete(C)</li>
  <li>Integrity is Partial(P) or Complete(C)</li>
  <li>Availability is Partial(P) or Complete(C)</li>
  </ol>
  </p>

  <p>Format string vulnerability:</p>
  <p>
  <ol>
  <li>Confidentiality is Partial(P) or Complete(C)</li>
  <li>Integrity is Partial(P) or Complete(C)</li>
  <li>Availability is Partial(P) or Complete(C)</li>
  </ol>
  </p>

  <p>Cross-site scripting vulnerability:</p>
  <p>
  <ol>
  <li>Confidentiality is None(N)</li>
  <li>Integrity is Partial(P) or Complete(C)</li>
  <li>Availability is Partial(P) or Complete(C)</li>
  </ol>
  </p>

  <p>SQL Injection vulnerability:</p>
  <p>
  <ol>
  <li>Confidentiality is Partial(P) or Complete(C)</li>
  <li>Integrity is Partial(P) or Complete(C)</li>
  <li>Availability is Partial(P) or Complete(C)</li>
  </ol>
  </p>

  <p>Directory traversal vulnerability:</p>
  <p>
  <ol>
  <li>Confidentiality is Partial(P) or Complete(C)</li>
  <li>Integrity is None(N)</li>
  <li>Availability is None(N)</li>
  </ol>
  </p>

  <p>File inclusion vulnerability:</p>
  <p>
  <ol>
  <li>Confidentiality is Partial(P) or Complete(C)</li>
  <li>Integrity is Partial(P) or Complete(C)</li>
  <li>Availability is Partial(P) or Complete(C)</li>
  </ol>
  </p>

  <p>Command execution vulnerability:</p>
  <p>
  <ol>
  <li>Confidentiality is Partial(P) or Complete(C)</li>
  <li>Integrity is Partial(P) or Complete(C)</li>
  <li>Availability is Partial(P) or Complete(C)</li>
  </ol>
  </p>

  <p>Information disclosure vulnerability:</p>
  <p>
  <ol>
  <li>Confidentiality is Partial(P) or Complete(C)</li>
  <li>Integrity is None(N)</li>
  <li>Availability is None(N)</li>
  </ol>
  </p>

  <p>Spoofing:</p>
  <p>
  <ol>
  <li>Confidentiality is Partial(P) or Complete(C)</li>
  <li>Integrity is None(N)</li>
  <li>Availability is None(N)</li>
  </ol>
  </p>

  <p>Session Hijacking:</p>
  <p>
  <ol>
  <li>Confidentiality is Partial(P) or Complete(C)</li>
  <li>Integrity is None(N)</li>
  <li>Availability is None(N)</li>
  </ol>
  </p>

  <p>Cross-site request forgery:</p>
  <p>
  <ol>
  <li>Confidentiality is Partial(P) or Complete(C)</li>
  <li>Integrity is None(N)</li>
  <li>Availability is None(N)</li>
  </ol>
  </p>

  <p>Code execution:</p>
  <p>
  <ol>
  <li>Confidentiality is Partial(P) or Complete(C)</li>
  <li>Integrity is Partial(P) or Complete(C)</li>
  <li>Availability is Partial(P) or Complete(C)</li>
  </ol>
  </p>

</ol>

<p>
The decision on whether to choose Partial(P) or Complete(C) is based on how much impact
it'll have on the target.
</p>

<a name="how_to_score"></a>
<h4>How to score</h4>
<p>
Once the values are chosen for each of the CVSS attributes, apply those values to CVSS
Calculator program available at:</p>

<p><a href="http://nvd.nist.gov/cvss.cfm?calculator&version=2">Common Vulnerability Scoring System Version 2 Calculator</a>
</p>

<a name="references"></a>
<h4>References</h4>
<ol>
<li>
<a href="http://www.first.org/cvss">CVSS Home page</a>
</li>
<li>
<a href="http://www.first.org/cvss/cvss-guide.pdf">CVSS Guide</a>
</li>
<li>
<a href="http://nvd.nist.gov/cvss.cfm?calculator&version=2">CVSS v2 Calculator at NVD of NIST</a>
</li>
<li>
<a href="https://secinfo.greenbone.net/omp?cmd=cvss_calculator&token=guest">OpenVAS CVSS v2 Calculator at Greenbone SecInfo</a>
</li>
</ol>


<a name="how_to_deprecate_nvt"></a>
<h3>How to deprecate a NVT</h3>

<p>
In some (rare) situations it might be necessary to
deprecate a NVT so that it is not executed anymore
even if selected in a Scan-Config.
</p>

<p>
Simply removing it from the Feed is a suboptimal solution
because older Scan-Result will reference it and users
can not view details anymore, not at least that it
has been deprecated meanwhile.
</p>

<p>
Therefore this procedure is recommended for a deprecation:
</p>

<ol>

<li> <p>Update the description to inform that is is being deprecated
     and explain the reason why it has been deprecated.
     </p>
     <p>
     In case the NVT was replaced by another one, name this NVT and its
     OID. For example: "This NVT has been replaced by NVT "THE-TITLE" (OID: THE-FULL-OID)."
     </p>

<li> <p>
     Add the deprecation tag: script_tag(name:"deprecated", value:TRUE);
     </p>

<li> <p>
     Add an early "exit(66);". Of course this must be <em>after</em> the description block.
     The exit code 66 marks the NVT as deprecated to the scanner.
     </p>

</ol>

<a name="how_to_handle_rejected_cve"></a>
<h3>How to handle references to CVEs that are marked REJECTED</h3>

<p>
It may happen that a CVE is marked REJECTED over time but already
used as a reference in a NVT.
</p>

<p>
In this case the following procedure should be applied:
</p>

<ul>

<li> <p>
     In case other (not rejected) CVEs are present as references: Remove the CVE reference.
     </p>

<li> <p>
     In case it is the only CVE reference: Remove the CVE reference. Then evaluate whether
     the NVT creates a helpful log information for the user or collects helpful information
     for other NVTs.
     </p>
     <p>
     If so, then make the NVT a log-class NVT. Else deprecate the NVT.
     </p>

</ul>

<a name="how_to_handle_no_solution"></a>
<h3>How to handle NVTs with "no solution" for the user</h3>

<p>
It happens that for a vulnerability there is no solution for the user yet.
This usually is the case when the respective weakness was only recently
discovered. Of course a special solution can be a workaround or even disabling
a service, but no known patch or vendor update is available to actually close
the attack vector.
</p>

<p>
In the case no solution is available at time of writing the respective
tag should contain this sentence (dd is the day, mmmmmmmm the month
as a word, yyyy is the year; 'th' is 'nd' or 'rd' where appropriate):
</p>

<p> <em>
No solution available as of ddth mmmmmmmm, yyyy.
</em> </p>

<p>
Next, the solution_type must be set to "NoneAvailable".
</p>

<p>
After some time, solutions get available. But for some vulnerabilities
solutions are never worked out for a particular software release.
</p>

<p>
For updating the "no solution" information the following guide should be applied
(if getting aware of a solution, this can and should be applied anytime, independent
of the described schedule):
</p>

<p>
After one month after creation of the NVT, the solution availability must be re-checked
and if still no solution is available, the "No solution available as of ..." should be
updated with the current date.
</p>

<p>
After 6 month after creation of the NVT, the same must be done like after one
month.
</p>

<p>
If no solution becomes available for over 12 month after release of the NVT,
the phrase "No solution ..." in the tag "solution" must be replaced by:
</p>

<p> <em>
No solution or patch was made available for at least one year since
disclosure of this vulnerability. Likely none will be provided anymore.
General solution options are to upgrade to a newer release, disable
respective features, remove the product or replace the product by
another one.
</em> </p>

<p>
Also, the solution_type tag should be set to "WillNotFix".
</p>


<p>
And in case there is a work around:
</p>

<p> <em>
No solution or patch was made available for at least one year since
disclosure of this vulnerability. Likely none will be provided anymore.
General solution options are to upgrade to a newer release, disable
respective features, remove the product or replace the product by
another one.
</em> </p>

<p> <em>
A workaround is to ...
</em> </p>

<a name="how_to_assign_qod"></a>
<h3>How to assign a QoD to a NVT</h3>

<p>
The QoD is a value between 0% and 100% describing the
reliability of the executed vulnerability detection
or product detection.
</p>

<p>
One of the main reasons to introduce this concept was to handle
the challenge of potential vulnerabilities properly. The goal was to
keep such in the results database but only visible on demand.
</p>

<p>
While the QoD range allows to express the quality pretty refined,
in fact most of the test routines use a standard methodology.
Therefore the <b>QoD Types</b> were introduced of which each
is associated with a QoD value. The current list of types might
be extended over time.
</p>

<h4>Overview on QoD values and types</h4>

<table>

<tr>
  <th align="left">QoD</th>
  <th align="left">QoD Type(s)</th>
  <th align="left">Description</th>
</tr>

<tr>
  <td valign="top" align="right">100%</td>
  <td valign="top">exploit</td>
  <td valign="top">The detection happened via an exploit and therefore is fully verified.</td>
</tr>

<tr>
  <td valign="top" align="right">99%</td>
  <td valign="top">remote_vul</td>
  <td valign="top">
    Remote active checks (code execution, traversal attack, sql injection etc.) where
    the response clearly shows the presence of the vulnerability.
  </td>
</tr>

<tr>
  <td valign="top" align="right">98%</td>
  <td valign="top">remote_app</td>
  <td valign="top">
    Remote active checks (code execution, traversal attack, sql injection etc.) where
    the response clearly shows the presence of the vulnerable application.
  </td>
</tr>

<tr>
  <td valign="top" align="right">97%</td>
  <td valign="top">
    package
  </td>
  <td valign="top">
    Authenticated package-based checks for Linux(oid) systems.
  </td>
</tr>

<tr>
  <td valign="top" align="right">97%</td>
  <td valign="top">
    registry
  </td>
  <td valign="top">
    Authenticated registry-based checks for Windows systems.
  </td>
</tr>

<tr>
  <td valign="top" align="right">95%</td>
  <td valign="top">remote_active</td>
  <td valign="top">
    Remote active checks (code execution, traversal attack, sql injection etc.)
    where the response shows the likely presence of the vulnerable application
    or of the vulnerability.
    "Likely" means that only rare circumstances are possible where the detection
    would be wrong.
  </td>
</tr>

<tr>
  <td valign="top" align="right">80%</td>
  <td valign="top">
    remote_banner
  </td>
  <td valign="top">
    Remote banner check of applications that offer patch level in version. Many
    proprietary products do so.
  </td>
</tr>

<tr>
  <td valign="top" align="right">80%</td>
  <td valign="top">
    executable_version
  </td>
  <td valign="top">
    Authenticated executable version checks for Linux(oid) or Windows systems where
    applications offer patch level in version.
  </td>
</tr>

<tr>
  <td valign="top" align="right">75%</td>
  <td valign="top"></td>
  <td valign="top">
    This value was assigned to any pre-qod results during migration to OpenVAS-8
    and is also assigned for results from NVTs that do not own a qod. However,
    some NVTs eventually might own this value for some reason.
  </td>
</tr>

<tr>
  <td valign="top" align="right">70%</td>
  <td valign="top">remote_analysis</td>
  <td valign="top">
    Remote checks that do some analysis but which are not always
    fully reliable.
  </td>
</tr>

<tr>
  <td valign="top" align="right">50%</td>
  <td valign="top">remote_probe</td>
  <td valign="top">
    Remote checks where intermediate systems such as firewalls might pretend
    correct detection so that it is actually not clear whether the application
    itself answered. This can happen for example for non-TLS connections.</td>
</tr>

<tr>
  <td valign="top" align="right">30%</td>
  <td valign="top">
    remote_banner_unreliable
  </td>
  <td valign="top">
    Remote Banner checks of applications that don't offer patch level in version identification.
    For example, this is the case for many Open Source products due to backport patches.
  </td>
</tr>

<tr>
  <td valign="top" align="right">30%</td>
  <td valign="top">
    executable_version_unreliable
  </td>
  <td valign="top">
    Authenticated executable version checks for Linux(oid) systems where applications
    don't offer patch level in version identification.
  </td>
</tr>

<tr>
  <td valign="top" align="right">1%</td>
  <td valign="top">general_note</td>
  <td valign="top">
    General note on potential vulnerability without finding any present application.
  </td>
</tr>

</table>

<h4>Transition phase for NVTs and results</h4>

<p>
The value of 70% is the default minimum used for the default filtering
to display the results in the reports.
</p>

<p>
The QoD is introduced with OpenVAS-8. Any results created with prior
versions are assigned the value of 75% during migration.
</p>

<p>
The transition of the NVTs is a long-term activity. For NVTs that
have no QoD assigned yet, scan results will be assigned with 75%.
</p>

<p>
This setting of 75% ensures that by default the results are visible
as before. However, eventually new results might occur with a QoD of 75%.
So, this value can not automatically be interpreted as "old pre-qod result".
</p>

<a name="how_to_assign_solution_type"></a>
<h3>How to assign a solution type to a NVT</h3>

<p>
This describes the type of solution available for the vulnerability in a formal way.
Use one of the following keywords.
</p>

<p>
<b>Workaround</b>:
Information is available about a configuration or specific
deployment scenario that can be used to avoid exposure to the vulnerability.
There may be none, one, or more workarounds available. This is typically the
"first line of defense" against a new vulnerability before a mitigation or
vendor fix has been issued or even discovered.
</p>

<p>
<b>Mitigation:</b>
Information is available about a configuration or deployment scenario that
helps to reduce the risk of the vulnerability but that does not resolve the
vulnerability on the affected product. Mitigations may include using devices or
access controls external to the affected product. Mitigations may or may not be
issued by the original author of the affected product, and they may or may not
be officially sanctioned by the document producer.
</p>

<p>
<b>VendorFix:</b>
Information is available about an official fix that is issued by the original
author of the affected product. Unless otherwise noted, it is assumed that this
fix fully resolves the vulnerability.
</p>

<p>
<b>NoneAvailable:</b>
Currently there is no fix available. Information should contain details about
why there is no fix.
</p>

<p>
<b>WillNotFix:</b>
There is no fix for the vulnerability and there never will be one. This is
often the case when a product has been orphaned, end-of-lifed, or otherwise
deprecated. Information should contain details about why there will be no fix
issued.
</p>

<p>
<b>Policy:</b>
It remains a decision of the user to regard the detected situation as a
vulnerability and to apply some methods or changes in order to
establish security compliance. The actual solution usually is a configuration
change.
</p>

<p>
<b>NoneRequired:</b>
An information is gathered in order to support some vulnerability 
evaluation.
There is no solution required for the information gathering as such.
</p>

